{
  "version": 3,
  "sources": ["../src/startStopwatch.ts", "../src/backend/stopwatchBackend.ts", "../src/backend/utils.ts"],
  "sourcesContent": ["import { closeMainWindow } from \"@raycast/api\";\nimport { startStopwatch } from \"./backend/stopwatchBackend\";\nimport { SWInlineArgs } from \"./backend/types\";\n\nexport default async (props: { arguments: SWInlineArgs }) => {\n  await closeMainWindow();\n  if (props.arguments.name) {\n    startStopwatch({ swName: props.arguments.name });\n  } else {\n    startStopwatch({});\n  }\n};\n", "import { environment } from \"@raycast/api\";\nimport { execSync } from \"child_process\";\nimport { randomUUID } from \"crypto\";\nimport { existsSync, readdirSync, readFileSync, writeFileSync } from \"fs\";\nimport { extname } from \"path\";\nimport { secondsBetweenDates } from \"./formatUtils\";\nimport { Stopwatch, StopwatchLaunchConfig } from \"./types\";\nimport { showHudOrToast } from \"./utils\";\n\nconst SWPATH = environment.supportPath + \"/raycast-stopwatches.json\";\n\nconst ensureSWFileExists = () => {\n  if (!existsSync(SWPATH) || readFileSync(SWPATH).toString() == \"\") {\n    writeFileSync(SWPATH, \"[]\");\n  }\n};\n\nconst initStopwatch = (swName: string): Stopwatch => {\n  return {\n    name: swName,\n    swID: randomUUID(),\n    timeStarted: new Date(),\n    timeElapsed: -99,\n    lastPaused: \"----\",\n    pauseElapsed: 0,\n  };\n};\n\nconst processStopwatches = (swSet: Stopwatch[]) => {\n  swSet.map((x) => {\n    if (x.lastPaused != \"----\") {\n      x.timeElapsed = Math.max(0, secondsBetweenDates({ d1: x.lastPaused, d2: x.timeStarted }) - x.pauseElapsed);\n    } else {\n      const rawElapsedTime = Math.max(0, secondsBetweenDates({ d2: x.timeStarted }));\n      x.timeElapsed = rawElapsedTime - x.pauseElapsed;\n    }\n  });\n  return swSet;\n};\n\nconst getStopwatches = () => {\n  ensureSWFileExists();\n  const rawStopwatches: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  const fullStopwatchSet = cleanUpOldStopwatches(rawStopwatches);\n  const setOfStopwatches = processStopwatches(fullStopwatchSet);\n  setOfStopwatches.sort((a, b) => {\n    return a.timeElapsed - b.timeElapsed;\n  });\n  return setOfStopwatches;\n};\n\nconst startStopwatch = async ({ swName = \"Untitled\", launchedFromMenuBar = false }: StopwatchLaunchConfig) => {\n  ensureSWFileExists();\n  const swStore: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  const newTimer = initStopwatch(swName);\n  swStore.push(newTimer);\n  writeFileSync(SWPATH, JSON.stringify(swStore));\n\n  showHudOrToast({ msg: `Stopwatch \"${swName}\" started!`, launchedFromMenuBar: launchedFromMenuBar, isErr: false });\n};\n\nconst pauseStopwatch = (swToPause: string) => {\n  ensureSWFileExists();\n  let swStore: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  swStore = swStore.map((s) => (s.swID == swToPause ? { ...s, lastPaused: new Date() } : s));\n  writeFileSync(SWPATH, JSON.stringify(swStore));\n};\n\nconst unpauseStopwatch = (swToUnpause: string) => {\n  ensureSWFileExists();\n  let swStore: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  swStore = swStore.map((s) =>\n    s.swID == swToUnpause\n      ? {\n          ...s,\n          pauseElapsed: s.pauseElapsed + secondsBetweenDates({ d2: s.lastPaused }),\n          lastPaused: \"----\",\n        }\n      : s,\n  );\n  writeFileSync(SWPATH, JSON.stringify(swStore));\n};\n\nconst stopStopwatch = (swToDelete: string) => {\n  ensureSWFileExists();\n  let swStore: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  swStore = swStore.filter((s: Stopwatch) => s.swID !== swToDelete);\n  writeFileSync(SWPATH, JSON.stringify(swStore));\n};\n\nconst cleanUpOldStopwatches = (newStore: Stopwatch[]) => {\n  const files = readdirSync(environment.supportPath);\n  files.forEach((swFile: string) => {\n    if (extname(swFile) == \".stopwatch\") {\n      const stopwatch = initStopwatch(readFileSync(environment.supportPath + \"/\" + swFile).toString());\n      const timeStarted = swFile.replace(/__/g, \":\").replace(\".stopwatch\", \"\");\n      stopwatch.timeStarted = new Date(timeStarted);\n      stopwatch.timeElapsed = Math.max(0, secondsBetweenDates({}));\n      execSync(`rm \"${environment.supportPath}/${swFile}\"`);\n      newStore.push(stopwatch);\n    }\n  });\n  writeFileSync(SWPATH, JSON.stringify(newStore));\n  return newStore;\n};\n\nconst renameStopwatch = (swID: string, newName: string) => {\n  ensureSWFileExists();\n  const stopwatches: Stopwatch[] = JSON.parse(readFileSync(SWPATH, \"utf8\"));\n  const renamedSW = stopwatches.map((x) => (x.swID == swID ? { ...x, name: newName } : x));\n  writeFileSync(SWPATH, JSON.stringify(renamedSW));\n};\n\nexport { getStopwatches, pauseStopwatch, unpauseStopwatch, startStopwatch, stopStopwatch, renameStopwatch };\n", "import {\n  Icon,\n  Toast,\n  confirmAlert,\n  environment,\n  getPreferenceValues,\n  popToRoot,\n  showHUD,\n  showToast,\n} from \"@raycast/api\";\nimport { Preferences } from \"./types\";\nimport { existsSync, writeFileSync } from \"fs\";\n\nconst shortCircuitMenuBar = <T>(state: T[] | undefined, prefs: Preferences): boolean => {\n  return (\n    (state == undefined || state.length == 0 || state.length == undefined) &&\n    ![\"always\", \"onlyWhenNotRunning\"].includes(prefs.showMenuBarIconWhen)\n  );\n};\n\nconst showHudOrToast = (args: { msg: string; launchedFromMenuBar: boolean; isErr: boolean }) => {\n  const prefs: Preferences = getPreferenceValues();\n  if (args.launchedFromMenuBar || prefs.closeWindowOnTimerStart) {\n    const msgEmoji = args.isErr ? \"\u26A0\uFE0F\" : \"\uD83C\uDF89\";\n    showHUD(`${msgEmoji} ${args.msg}`);\n    return popToRoot();\n  } else {\n    showToast({ style: args.isErr ? Toast.Style.Failure : Toast.Style.Success, title: args.msg });\n  }\n};\n\nconst showInitialRingContinuouslyWarning = async (): Promise<boolean> => {\n  const RINGCONTINUOUSLY_SHOWN_PATH = environment.supportPath + \"/ringContinuouslyWarningShown\";\n  const prefs = getPreferenceValues<Preferences>();\n  if (!prefs.ringContinuously) return true;\n  if (existsSync(RINGCONTINUOUSLY_SHOWN_PATH)) return true;\n\n  const result = await confirmAlert({\n    title: \"Ring Continuously is enabled!\",\n    icon: Icon.Bell,\n    message:\n      'When the timer rings, you will need to use the \"Stop Running Timer\" command or stop the timer in the \"Manage Timers\" command to dismiss the sound. You can configure this in your Raycast settings.',\n  });\n  if (result) writeFileSync(RINGCONTINUOUSLY_SHOWN_PATH, \"\");\n  return result;\n};\n\nexport { shortCircuitMenuBar, showHudOrToast, showInitialRingContinuouslyWarning };\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAgC,wBCAhC,IAAAC,EAA4B,wBAE5B,IAAAC,EAA2B,kBAC3BC,EAAqE,cCHrE,IAAAC,EASO,wBAWP,IAAMC,EAAkBC,GAAwE,CAC9F,IAAMC,KAAqB,uBAAoB,EAC/C,GAAID,EAAK,qBAAuBC,EAAM,wBAAyB,CAC7D,IAAMC,EAAWF,EAAK,MAAQ,eAAO,YACrC,oBAAQ,GAAGE,CAAQ,IAAIF,EAAK,GAAG,EAAE,KAC1B,aAAU,CACnB,QACE,aAAU,CAAE,MAAOA,EAAK,MAAQ,QAAM,MAAM,QAAU,QAAM,MAAM,QAAS,MAAOA,EAAK,GAAI,CAAC,CAEhG,EDpBA,IAAMG,EAAS,cAAY,YAAc,4BAEnCC,EAAqB,IAAM,EAC3B,IAAC,cAAWD,CAAM,MAAK,gBAAaA,CAAM,EAAE,SAAS,GAAK,QAC5D,iBAAcA,EAAQ,IAAI,CAE9B,EAEME,EAAiBC,IACd,CACL,KAAMA,EACN,QAAM,cAAW,EACjB,YAAa,IAAI,KACjB,YAAa,IACb,WAAY,OACZ,aAAc,CAChB,GA0BF,IAAMC,EAAiB,MAAO,CAAE,OAAAC,EAAS,WAAY,oBAAAC,EAAsB,EAAM,IAA6B,CAC5GC,EAAmB,EACnB,IAAMC,EAAuB,KAAK,SAAM,gBAAaC,CAAM,EAAE,SAAS,CAAC,EACjEC,EAAWC,EAAcN,CAAM,EACrCG,EAAQ,KAAKE,CAAQ,KACrB,iBAAcD,EAAQ,KAAK,UAAUD,CAAO,CAAC,EAE7CI,EAAe,CAAE,IAAK,cAAcP,CAAM,aAAc,oBAAqBC,EAAqB,MAAO,EAAM,CAAC,CAClH,EDvDA,IAAOO,EAAQ,MAAOC,GAAuC,CAC3D,QAAM,mBAAgB,EAClBA,EAAM,UAAU,KAClBC,EAAe,CAAE,OAAQD,EAAM,UAAU,IAAK,CAAC,EAE/CC,EAAe,CAAC,CAAC,CAErB",
  "names": ["startStopwatch_exports", "__export", "startStopwatch_default", "__toCommonJS", "import_api", "import_api", "import_crypto", "import_fs", "import_api", "showHudOrToast", "args", "prefs", "msgEmoji", "SWPATH", "ensureSWFileExists", "initStopwatch", "swName", "startStopwatch", "swName", "launchedFromMenuBar", "ensureSWFileExists", "swStore", "SWPATH", "newTimer", "initStopwatch", "showHudOrToast", "startStopwatch_default", "props", "startStopwatch"]
}

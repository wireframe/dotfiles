{
  "version": 3,
  "sources": ["../src/timersMenuBar.tsx", "../src/hooks/useTimers.ts", "../src/backend/timerBackend.ts", "../src/backend/formatUtils.ts", "../src/backend/utils.ts", "../src/backend/menuBarUtils.ts", "../src/hooks/useDefaultPresetVisibles.ts"],
  "sourcesContent": ["import { Icon, MenuBarExtra, launchCommand, LaunchType, getPreferenceValues } from \"@raycast/api\";\nimport { useEffect } from \"react\";\nimport useTimers from \"./hooks/useTimers\";\nimport { formatTime } from \"./backend/formatUtils\";\nimport { Preferences, Timer } from \"./backend/types\";\nimport { formatMenuBarIcon, formatMenuBarTitle } from \"./backend/menuBarUtils\";\nimport useDefaultPresetVisibles from \"./hooks/useDefaultPresetVisibles\";\nimport { shortCircuitMenuBar } from \"./backend/utils\";\n\nexport default function Command() {\n  const { timers, customTimers, isLoading, refreshTimers, handleStartTimer, handleStopTimer, handleStartCT } =\n    useTimers();\n  const { defaultPresets, defaultVisibles, refreshDefaultVisibles, isLoadingVisibles } = useDefaultPresetVisibles();\n\n  useEffect(() => {\n    refreshTimers();\n    refreshDefaultVisibles();\n    setInterval(() => {\n      refreshTimers();\n    }, 1000);\n  }, []);\n\n  if (isLoading) {\n    refreshTimers();\n  }\n  const prefs = getPreferenceValues<Preferences>();\n  if (shortCircuitMenuBar<Timer>(timers, prefs)) return null;\n\n  return (\n    <MenuBarExtra\n      icon={formatMenuBarIcon(timers, prefs, Icon.Clock)}\n      isLoading={isLoading && isLoadingVisibles}\n      title={formatMenuBarTitle<Timer>(timers, prefs)}\n    >\n      <MenuBarExtra.Item title=\"Click running timer to stop\" />\n      {timers?.map((timer) => (\n        <MenuBarExtra.Item\n          title={timer.name + \": \" + formatTime(timer.timeLeft) + \" left\"}\n          key={timer.originalFile}\n          onAction={() => handleStopTimer(timer)}\n        />\n      ))}\n\n      <MenuBarExtra.Section>\n        {Object.keys(customTimers)\n          ?.sort((a, b) => {\n            return customTimers[a].timeInSeconds - customTimers[b].timeInSeconds;\n          })\n          .filter((ctID) => customTimers[ctID].showInMenuBar)\n          .map((ctID) => (\n            <MenuBarExtra.Item\n              title={'Start \"' + customTimers[ctID].name + '\"'}\n              key={ctID}\n              onAction={() => handleStartCT({ customTimer: customTimers[ctID], launchedFromMenuBar: true })}\n            />\n          ))}\n      </MenuBarExtra.Section>\n\n      <MenuBarExtra.Section>\n        {defaultPresets\n          .filter((preset) => defaultVisibles?.[preset.key])\n          .map((defaultPreset) => (\n            <MenuBarExtra.Item\n              key={defaultPreset.key}\n              title={`Start ${defaultPreset.title}`}\n              onAction={() =>\n                handleStartTimer({\n                  timeInSeconds: defaultPreset.seconds,\n                  timerName: defaultPreset.title,\n                  launchedFromMenuBar: true,\n                })\n              }\n            />\n          ))}\n      </MenuBarExtra.Section>\n\n      <MenuBarExtra.Section title=\"Custom Timer\">\n        <MenuBarExtra.Item\n          title=\"Start Custom Timer\"\n          onAction={async () => await launchCommand({ name: \"startCustomTimer\", type: LaunchType.UserInitiated })}\n          key=\"custom\"\n        />\n      </MenuBarExtra.Section>\n    </MenuBarExtra>\n  );\n}\n", "import { useState } from \"react\";\nimport {\n  checkForOverlyLoudAlert,\n  createCustomTimer,\n  deleteCustomTimer,\n  ensureCTFileExists,\n  getTimers,\n  pauseTimer,\n  readCustomTimers,\n  startTimer,\n  stopTimer,\n  toggleCustomTimerMenubarVisibility,\n  unpauseTimer,\n} from \"../backend/timerBackend\";\nimport { CTLaunchConfig, CustomTimer, Timer, TimerLaunchConfig } from \"../backend/types\";\nimport { Alert, Icon, Toast, confirmAlert, showToast } from \"@raycast/api\";\n\nexport default function useTimers() {\n  const [timers, setTimers] = useState<Timer[] | undefined>(undefined);\n  const [customTimers, setCustomTimers] = useState<Record<string, CustomTimer>>({});\n  const [isLoading, setIsLoading] = useState<boolean>(timers === undefined);\n\n  const refreshTimers = () => {\n    ensureCTFileExists();\n    const setOfTimers: Timer[] = getTimers();\n    setTimers(setOfTimers);\n    const setOfCustomTimers: Record<string, CustomTimer> = readCustomTimers();\n    setCustomTimers(setOfCustomTimers);\n    setIsLoading(false);\n  };\n\n  const handleStartTimer = (launchConf: TimerLaunchConfig) => {\n    if (!checkForOverlyLoudAlert(launchConf.launchedFromMenuBar)) return;\n    startTimer(launchConf);\n    refreshTimers();\n  };\n\n  const handleStopTimer = (timer: Timer) => {\n    setTimers(timers?.filter((t: Timer) => t.originalFile !== timer.originalFile));\n    stopTimer(timer.originalFile);\n    refreshTimers();\n  };\n\n  const handlePauseTimer = (timer: Timer) => {\n    // cannot migrate old timers as we don't know PID\n    if (timer.pid == undefined && timer.lastPaused === \"---\")\n      return showToast({\n        style: Toast.Style.Failure,\n        title: \"This timer does not support pausing. Try restarting it to enable pausing.\",\n      });\n    pauseTimer(timer.originalFile, timer.pid!);\n    refreshTimers();\n  };\n\n  const handleUnpauseTimer = (timer: Timer) => {\n    // cannot migrate old timers as we don't know PID\n    if (timer.pid == undefined && timer.lastPaused === \"---\")\n      return showToast({\n        style: Toast.Style.Failure,\n        title: \"This timer does not support pausing. Try restarting it to enable pausing.\",\n      });\n    unpauseTimer(timer);\n    refreshTimers();\n  };\n\n  const handleStartCT = ({ customTimer, launchedFromMenuBar }: CTLaunchConfig) => {\n    if (!checkForOverlyLoudAlert(launchedFromMenuBar)) return;\n    startTimer({\n      timeInSeconds: customTimer.timeInSeconds,\n      launchedFromMenuBar: launchedFromMenuBar,\n      timerName: customTimer.name,\n      selectedSound: customTimer.selectedSound,\n    });\n    refreshTimers();\n  };\n\n  const handleCreateCT = (timer: Timer) => {\n    // TODO: make it possible to provide selected sound into CustomTimer\n    const customTimer: CustomTimer = {\n      name: timer.name,\n      timeInSeconds: timer.secondsSet,\n      selectedSound: \"default\",\n      showInMenuBar: true,\n    };\n    createCustomTimer(customTimer);\n    refreshTimers();\n  };\n\n  const handleDeleteCT = async (ctID: string) => {\n    const options: Alert.Options = {\n      title: \"Delete this preset?\",\n      icon: Icon.Trash,\n      message: \"You won't be able to recover it.\",\n      dismissAction: { title: \"Cancel\", style: Alert.ActionStyle.Cancel },\n      primaryAction: { title: \"Delete\", style: Alert.ActionStyle.Destructive },\n    };\n    if (await confirmAlert(options)) {\n      deleteCustomTimer(ctID);\n      refreshTimers();\n    }\n  };\n\n  const handleToggleCTVisibility = async (ctID: string) => {\n    toggleCustomTimerMenubarVisibility(ctID);\n    refreshTimers();\n  };\n\n  return {\n    timers,\n    customTimers,\n    isLoading,\n    refreshTimers,\n    handleStartTimer,\n    handlePauseTimer,\n    handleUnpauseTimer,\n    handleStopTimer,\n    handleStartCT,\n    handleCreateCT,\n    handleDeleteCT,\n    handleToggleCTVisibility,\n  };\n}\n", "import { environment, getPreferenceValues } from \"@raycast/api\";\nimport { exec } from \"child_process\";\nimport { randomUUID } from \"crypto\";\nimport { existsSync, readdirSync, readFileSync, unlinkSync, writeFileSync } from \"fs\";\nimport { extname } from \"path\";\nimport { CustomTimer, Preferences, RawTimer, Timer, TimerLaunchConfig } from \"./types\";\nimport { formatTime, secondsBetweenDates } from \"./formatUtils\";\nimport { showHudOrToast, showInitialRingContinuouslyWarning } from \"./utils\";\nimport { kill } from \"process\";\n\nconst DATAPATH = environment.supportPath + \"/customTimers.json\";\nconst DEFAULT_PRESET_VISIBLES_FILE = environment.supportPath + \"/defaultPresetVisibles.json\";\n\nconst silentFileDeletion = (fp: string) => {\n  try {\n    unlinkSync(fp);\n  } catch (err) {\n    // only throw if it's not a \"file doesn't exist\" error\n    if (err instanceof Error && !err.message.includes(\"ENOENT\")) throw err;\n  }\n};\n\nconst checkForOverlyLoudAlert = (launchedFromMenuBar = false) => {\n  const prefs = getPreferenceValues<Preferences>();\n  if (parseFloat(prefs.volumeSetting) > 5.0) {\n    const errorMsg = \"Timer alert volume should not be louder than 5 (it can get quite loud!)\";\n    showHudOrToast({ msg: errorMsg, launchedFromMenuBar: launchedFromMenuBar, isErr: true });\n    return false;\n  }\n  return true;\n};\n\nasync function startTimer({\n  timeInSeconds,\n  timerName = \"Untitled\",\n  launchedFromMenuBar = false,\n  selectedSound = \"default\",\n  skipRingContinuouslyWarning = false,\n}: TimerLaunchConfig) {\n  if (!skipRingContinuouslyWarning) {\n    if (!(await showInitialRingContinuouslyWarning())) return;\n  }\n  const fileName = environment.supportPath + \"/\" + new Date().toISOString() + \"---\" + timeInSeconds + \".timer\";\n  const masterName = fileName.replace(/:/g, \"__\");\n\n  const prefs = getPreferenceValues<Preferences>();\n  if (prefs.ringContinuously) {\n    const dismissFile = `${masterName}`.replace(\".timer\", \".dismiss\");\n    writeFileSync(dismissFile, \".dismiss file for Timers\");\n  }\n\n  const cmd = buildTimerCommand(masterName, timerName, timeInSeconds, selectedSound);\n\n  const process = exec(cmd, (error, stderr) => {\n    if (error) {\n      console.log(`error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.log(`stderr: ${stderr}`);\n      return;\n    }\n  });\n\n  const fileContents: RawTimer = {\n    name: timerName,\n    pid: process.pid,\n    lastPaused: \"---\",\n    pauseElapsed: 0,\n    selectedSound: selectedSound === \"default\" ? prefs.selectedSound : selectedSound,\n  };\n  writeFileSync(masterName, JSON.stringify(fileContents));\n  showHudOrToast({\n    msg: `Timer \"${timerName}\" started for ${formatTime(timeInSeconds)}!`,\n    launchedFromMenuBar: launchedFromMenuBar,\n    isErr: false,\n  });\n}\n\nfunction buildTimerCommand(\n  masterName: string,\n  timerName: string,\n  timeInSeconds: number,\n  selectedSound: string,\n): string {\n  const prefs = getPreferenceValues<Preferences>();\n  const selectedSoundPath = `${\n    environment.assetsPath + \"/\" + (selectedSound === \"default\" ? prefs.selectedSound : selectedSound)\n  }`;\n  const cmdParts = [`sleep ${timeInSeconds}`];\n  cmdParts.push(\n    `if [ -f \"${masterName}\" ]; then osascript -e 'display notification \"Timer \\\\\"${timerName}\\\\\" complete\" with title \"Ding!\"'`,\n  );\n  const alertSoundString =\n    prefs.selectedSound === \"speak_timer_name\"\n      ? `say ${timerName}`\n      : `afplay \"${selectedSoundPath}\" --volume ${prefs.volumeSetting.replace(\",\", \".\")}`;\n  cmdParts.push(alertSoundString);\n  if (prefs.ringContinuously) {\n    const dismissFile = `${masterName}`.replace(\".timer\", \".dismiss\");\n    cmdParts.push(`while [ -f \"${dismissFile}\" ]; do ${alertSoundString}; done`);\n  }\n  cmdParts.push(`rm \"${masterName}\"; else echo \"Timer deleted\"; fi`);\n  return cmdParts.join(\" ; \");\n}\n\nfunction stopTimer(timerFile: string) {\n  const timerFilePath = environment.supportPath + \"/\" + timerFile;\n  const dismissFile = timerFilePath.replace(\".timer\", \".dismiss\");\n  silentFileDeletion(timerFilePath);\n  silentFileDeletion(dismissFile);\n}\n\nfunction pauseTimer(timerFile: string, timerPid: number) {\n  const timerFilePath = environment.supportPath + \"/\" + timerFile;\n  kill(timerPid);\n\n  const rawFileContents = readFileSync(timerFilePath).toString();\n  const fileContents: RawTimer = JSON.parse(rawFileContents);\n  fileContents.pid = undefined;\n  fileContents.lastPaused = new Date();\n  writeFileSync(timerFilePath, JSON.stringify(fileContents));\n}\n\nfunction unpauseTimer(timer: Timer) {\n  const timerFilePath = environment.supportPath + \"/\" + timer.originalFile;\n\n  const cmd = buildTimerCommand(timerFilePath, timer.name, timer.timeLeft, timer.selectedSound);\n  const process = exec(cmd);\n\n  const rawFileContents = readFileSync(timerFilePath).toString();\n  const fileContents: RawTimer = JSON.parse(rawFileContents);\n  fileContents.pauseElapsed = fileContents.pauseElapsed + secondsBetweenDates({ d2: timer.lastPaused });\n  fileContents.lastPaused = \"---\";\n  fileContents.pid = process.pid;\n  writeFileSync(timerFilePath, JSON.stringify(fileContents));\n}\n\nfunction getTimers() {\n  const setOfTimers: Timer[] = [];\n  const files = readdirSync(environment.supportPath);\n  files.forEach((timerFile: string) => {\n    if (extname(timerFile) == \".timer\") {\n      const timer: Timer = {\n        name: \"\",\n        secondsSet: -99,\n        timeLeft: -99,\n        originalFile: timerFile,\n        timeEnds: new Date(),\n        pid: undefined,\n        lastPaused: \"---\",\n        pauseElapsed: 0,\n        selectedSound: \"default\",\n      };\n      const rawFileContents = readFileSync(environment.supportPath + \"/\" + timerFile).toString();\n      try {\n        const fileContents: RawTimer = JSON.parse(rawFileContents);\n        timer.name = fileContents.name;\n        timer.pid = fileContents.pid;\n        timer.lastPaused = fileContents.lastPaused;\n        timer.pauseElapsed = fileContents.pauseElapsed;\n        timer.selectedSound = fileContents.selectedSound;\n      } catch (error) {\n        if (!(error instanceof SyntaxError)) throw error;\n        timer.name = rawFileContents;\n      }\n\n      const timerFileParts = timerFile.split(\"---\");\n      timer.secondsSet = Number(timerFileParts[1].split(\".\")[0]);\n      const timeStarted = timerFileParts[0].replace(/__/g, \":\");\n      timer.timeEnds = new Date(timeStarted);\n      timer.timeEnds.setSeconds(timer.timeEnds.getSeconds() + timer.secondsSet + timer.pauseElapsed);\n      timer.timeLeft = Math.max(\n        0,\n        Math.round(\n          timer.pid === undefined\n            ? timer.secondsSet -\n                secondsBetweenDates({\n                  d1: timer.lastPaused === \"---\" ? undefined : timer.lastPaused,\n                  d2: new Date(timeStarted),\n                }) +\n                timer.pauseElapsed\n            : secondsBetweenDates({ d1: timer.timeEnds }),\n        ),\n      );\n      setOfTimers.push(timer);\n    }\n  });\n  setOfTimers.sort((a, b) => {\n    return a.timeLeft - b.timeLeft;\n  });\n  return setOfTimers;\n}\n\nfunction renameTimer(timerFile: string, newName: string) {\n  const timerFilePath = environment.supportPath + \"/\" + timerFile;\n  const rawFileContents = readFileSync(timerFilePath).toString();\n  const fileContents: RawTimer = JSON.parse(rawFileContents);\n  fileContents.name = newName;\n  writeFileSync(timerFilePath, JSON.stringify(fileContents));\n}\n\nfunction ensureCTFileExists() {\n  if (!existsSync(DATAPATH)) {\n    writeFileSync(DATAPATH, JSON.stringify({}));\n  }\n}\n\nfunction createCustomTimer(newTimer: CustomTimer) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  customTimers[randomUUID()] = newTimer;\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nfunction readCustomTimers() {\n  ensureCTFileExists();\n  const res: Record<string, CustomTimer> = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  return Object.fromEntries(\n    Object.entries(res).map(([ctID, timer]) =>\n      timer.showInMenuBar === undefined ? [ctID, { ...timer, showInMenuBar: true }] : [ctID, timer],\n    ),\n  );\n}\n\nfunction renameCustomTimer(ctID: string, newName: string) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  customTimers[ctID].name = newName;\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nfunction deleteCustomTimer(ctID: string) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  delete customTimers[ctID];\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nfunction toggleCustomTimerMenubarVisibility(ctID: string) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  const currentVisibility = customTimers[ctID].showInMenuBar;\n  customTimers[ctID].showInMenuBar = currentVisibility === undefined ? false : !currentVisibility;\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nconst readDefaultPresetVisibles = (): Record<string, boolean> => {\n  if (!existsSync(DEFAULT_PRESET_VISIBLES_FILE)) {\n    const defaultPresetVisibles = {\n      \"2M\": true,\n      \"5M\": true,\n      \"10M\": true,\n      \"15M\": true,\n      \"30M\": true,\n      \"45M\": true,\n      \"60M\": true,\n      \"90M\": true,\n    };\n    writeFileSync(DEFAULT_PRESET_VISIBLES_FILE, JSON.stringify(defaultPresetVisibles));\n    return defaultPresetVisibles;\n  }\n  const res: Record<string, boolean> = JSON.parse(readFileSync(DEFAULT_PRESET_VISIBLES_FILE, \"utf8\"));\n  return res;\n};\n\nconst toggleDefaultPresetVisibility = (key: string) => {\n  const data: Record<string, boolean> = JSON.parse(readFileSync(DEFAULT_PRESET_VISIBLES_FILE, \"utf8\"));\n  data[key] = !data[key];\n  writeFileSync(DEFAULT_PRESET_VISIBLES_FILE, JSON.stringify(data));\n};\n\nexport {\n  checkForOverlyLoudAlert,\n  createCustomTimer,\n  deleteCustomTimer,\n  ensureCTFileExists,\n  getTimers,\n  readCustomTimers,\n  renameTimer,\n  renameCustomTimer,\n  toggleCustomTimerMenubarVisibility,\n  startTimer,\n  stopTimer,\n  pauseTimer,\n  unpauseTimer,\n  readDefaultPresetVisibles,\n  toggleDefaultPresetVisibility,\n};\n", "const formatTime = (seconds: number) => {\n  const hours = Math.floor(seconds / 3600);\n  const mins = String(Math.floor((seconds % 3600) / 60)).padStart(2, \"0\");\n  const secs = String(Math.floor(seconds % 60)).padStart(2, \"0\");\n  return `${hours === 0 ? \"\" : hours + \":\"}${mins}:${secs}`;\n};\n\nconst formatDateTime = (d: Date) => {\n  const parsedDate = new Date(d);\n  const datevalues = [\n    parsedDate.getFullYear().toString(),\n    (parsedDate.getMonth() + 1).toString().padStart(2, \"0\"),\n    parsedDate.getDate().toString().padStart(2, \"0\"),\n  ];\n  const timevalues = [parsedDate.getHours(), parsedDate.getMinutes(), parsedDate.getSeconds()].map((x) =>\n    x.toString().padStart(2, \"0\"),\n  );\n  const date = datevalues.join(\"-\");\n  const time = timevalues.join(\":\");\n  return `${date} ${time}`;\n};\n\nconst secondsBetweenDates = (args: { d1?: Date | string; d2?: Date | string }) => {\n  args.d1 = args.d1 == \"----\" ? undefined : args.d1;\n  args.d2 = args.d2 == \"----\" ? undefined : args.d2;\n  return (\n    Math.round(\n      (args.d1 ? new Date(args.d1) : new Date()).getTime() - (args.d2 ? new Date(args.d2) : new Date()).getTime(),\n    ) / 1000\n  );\n};\n\nexport { formatTime, formatDateTime, secondsBetweenDates };\n", "import {\n  Icon,\n  Toast,\n  confirmAlert,\n  environment,\n  getPreferenceValues,\n  popToRoot,\n  showHUD,\n  showToast,\n} from \"@raycast/api\";\nimport { Preferences } from \"./types\";\nimport { existsSync, writeFileSync } from \"fs\";\n\nconst shortCircuitMenuBar = <T>(state: T[] | undefined, prefs: Preferences): boolean => {\n  return (\n    (state == undefined || state.length == 0 || state.length == undefined) &&\n    ![\"always\", \"onlyWhenNotRunning\"].includes(prefs.showMenuBarIconWhen)\n  );\n};\n\nconst showHudOrToast = (args: { msg: string; launchedFromMenuBar: boolean; isErr: boolean }) => {\n  const prefs: Preferences = getPreferenceValues();\n  if (args.launchedFromMenuBar || prefs.closeWindowOnTimerStart) {\n    const msgEmoji = args.isErr ? \"\u26A0\uFE0F\" : \"\uD83C\uDF89\";\n    showHUD(`${msgEmoji} ${args.msg}`);\n    return popToRoot();\n  } else {\n    showToast({ style: args.isErr ? Toast.Style.Failure : Toast.Style.Success, title: args.msg });\n  }\n};\n\nconst showInitialRingContinuouslyWarning = async (): Promise<boolean> => {\n  const RINGCONTINUOUSLY_SHOWN_PATH = environment.supportPath + \"/ringContinuouslyWarningShown\";\n  const prefs = getPreferenceValues<Preferences>();\n  if (!prefs.ringContinuously) return true;\n  if (existsSync(RINGCONTINUOUSLY_SHOWN_PATH)) return true;\n\n  const result = await confirmAlert({\n    title: \"Ring Continuously is enabled!\",\n    icon: Icon.Bell,\n    message:\n      'When the timer rings, you will need to use the \"Stop Running Timer\" command or stop the timer in the \"Manage Timers\" command to dismiss the sound. You can configure this in your Raycast settings.',\n  });\n  if (result) writeFileSync(RINGCONTINUOUSLY_SHOWN_PATH, \"\");\n  return result;\n};\n\nexport { shortCircuitMenuBar, showHudOrToast, showInitialRingContinuouslyWarning };\n", "import { Icon } from \"@raycast/api\";\nimport { formatTime } from \"./formatUtils\";\nimport { Preferences, Stopwatch, Timer } from \"./types\";\n\nconst formatMenuBarTitle = <T extends Timer | Stopwatch>(\n  state: T[] | undefined,\n  prefs: Preferences,\n): string | undefined => {\n  if (state === undefined || state?.length === 0 || state.length == undefined) return undefined;\n\n  const runTime = \"timeLeft\" in state[0] ? state[0].timeLeft : state[0].timeElapsed;\n  if (prefs.showTitleInMenuBar) {\n    return `${state[0].name}: ~${formatTime(runTime)}`;\n  } else {\n    return `~${formatTime(runTime)}`;\n  }\n};\n\nconst formatMenuBarIcon = <T>(state: T[] | undefined, prefs: Preferences, icon: Icon): Icon | undefined => {\n  switch (prefs.showMenuBarIconWhen) {\n    case \"always\":\n      return icon;\n    case \"never\":\n      return undefined;\n    case \"onlyWhenRunning\":\n      return state !== undefined && state?.length > 0 ? icon : undefined;\n    case \"onlyWhenNotRunning\":\n      return state === undefined || state?.length === 0 ? icon : undefined;\n  }\n};\n\nexport { formatMenuBarTitle, formatMenuBarIcon };\n", "import { useState } from \"react\";\nimport { DefaultTimerPreset } from \"../backend/types\";\nimport { readDefaultPresetVisibles, toggleDefaultPresetVisibility } from \"../backend/timerBackend\";\n\nexport default function useDefaultPresetVisibles() {\n  const defaultPresets: DefaultTimerPreset[] = [\n    {\n      key: \"2M\",\n      title: \"2 Minute Timer\",\n      seconds: 60 * 2,\n    },\n    {\n      key: \"5M\",\n      title: \"5 Minute Timer\",\n      seconds: 60 * 5,\n    },\n    {\n      key: \"10M\",\n      title: \"10 Minute Timer\",\n      seconds: 60 * 10,\n    },\n    {\n      key: \"15M\",\n      title: \"15 Minute Timer\",\n      seconds: 60 * 15,\n    },\n    {\n      key: \"30M\",\n      title: \"30 Minute Timer\",\n      seconds: 60 * 30,\n    },\n    {\n      key: \"45M\",\n      title: \"45 Minute Timer\",\n      seconds: 60 * 45,\n    },\n    {\n      key: \"60M\",\n      title: \"60 Minute Timer\",\n      seconds: 60 * 60,\n    },\n    {\n      key: \"90M\",\n      title: \"90 Minute Timer\",\n      seconds: 60 * 60 * 1.5,\n    },\n  ];\n\n  const [defaultVisibles, setDefaultVisibles] = useState<Record<string, boolean> | undefined>();\n  const [isLoadingVisibles, setIsLoadingVisibles] = useState<boolean>(defaultVisibles === undefined);\n\n  const refreshDefaultVisibles = () => {\n    setDefaultVisibles(readDefaultPresetVisibles());\n    setIsLoadingVisibles(false);\n  };\n\n  const handleDefaultPresetToggle = (key: string) => {\n    toggleDefaultPresetVisibility(key);\n    refreshDefaultVisibles();\n  };\n\n  return {\n    defaultPresets,\n    defaultVisibles,\n    isLoadingVisibles,\n    refreshDefaultVisibles,\n    handleDefaultPresetToggle,\n  };\n}\n"],
  "mappings": "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",
  "names": ["timersMenuBar_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "import_react", "import_api", "import_child_process", "import_crypto", "import_fs", "import_path", "formatTime", "seconds", "hours", "mins", "secs", "secondsBetweenDates", "args", "import_api", "import_fs", "shortCircuitMenuBar", "state", "prefs", "showHudOrToast", "args", "msgEmoji", "showInitialRingContinuouslyWarning", "RINGCONTINUOUSLY_SHOWN_PATH", "result", "import_process", "DATAPATH", "DEFAULT_PRESET_VISIBLES_FILE", "silentFileDeletion", "fp", "err", "checkForOverlyLoudAlert", "launchedFromMenuBar", "prefs", "showHudOrToast", "startTimer", "timeInSeconds", "timerName", "selectedSound", "skipRingContinuouslyWarning", "showInitialRingContinuouslyWarning", "masterName", "dismissFile", "cmd", "buildTimerCommand", "process", "error", "stderr", "fileContents", "formatTime", "selectedSoundPath", "cmdParts", "alertSoundString", "stopTimer", "timerFile", "timerFilePath", "pauseTimer", "timerPid", "rawFileContents", "unpauseTimer", "timer", "secondsBetweenDates", "getTimers", "setOfTimers", "timerFileParts", "timeStarted", "a", "b", "ensureCTFileExists", "DATAPATH", "createCustomTimer", "newTimer", "customTimers", "readCustomTimers", "res", "ctID", "timer", "deleteCustomTimer", "ctID", "ensureCTFileExists", "customTimers", "DATAPATH", "toggleCustomTimerMenubarVisibility", "currentVisibility", "readDefaultPresetVisibles", "DEFAULT_PRESET_VISIBLES_FILE", "defaultPresetVisibles", "toggleDefaultPresetVisibility", "key", "data", "import_api", "useTimers", "timers", "setTimers", "customTimers", "setCustomTimers", "isLoading", "setIsLoading", "refreshTimers", "ensureCTFileExists", "setOfTimers", "getTimers", "setOfCustomTimers", "readCustomTimers", "launchConf", "checkForOverlyLoudAlert", "startTimer", "timer", "pauseTimer", "unpauseTimer", "t", "stopTimer", "customTimer", "launchedFromMenuBar", "createCustomTimer", "ctID", "options", "deleteCustomTimer", "toggleCustomTimerMenubarVisibility", "formatMenuBarTitle", "state", "prefs", "runTime", "formatTime", "formatMenuBarIcon", "icon", "import_react", "useDefaultPresetVisibles", "defaultPresets", "defaultVisibles", "setDefaultVisibles", "isLoadingVisibles", "setIsLoadingVisibles", "refreshDefaultVisibles", "readDefaultPresetVisibles", "key", "toggleDefaultPresetVisibility", "import_jsx_runtime", "Command", "timers", "customTimers", "isLoading", "refreshTimers", "handleStartTimer", "handleStopTimer", "handleStartCT", "useTimers", "defaultPresets", "defaultVisibles", "refreshDefaultVisibles", "isLoadingVisibles", "useDefaultPresetVisibles", "prefs", "shortCircuitMenuBar", "formatMenuBarIcon", "formatMenuBarTitle", "timer", "formatTime", "a", "b", "ctID", "preset", "defaultPreset"]
}

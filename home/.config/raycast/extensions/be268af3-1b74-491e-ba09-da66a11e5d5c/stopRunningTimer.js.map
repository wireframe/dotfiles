{
  "version": 3,
  "sources": ["../src/stopRunningTimer.ts", "../src/backend/timerBackend.ts", "../src/backend/formatUtils.ts", "../src/backend/utils.ts"],
  "sourcesContent": ["import { closeMainWindow, showHUD, showToast, Toast } from \"@raycast/api\";\nimport { getTimers, stopTimer } from \"./backend/timerBackend\";\n\nexport default async () => {\n  const timers = getTimers();\n  if (timers.length === 0) {\n    return await showToast({\n      style: Toast.Style.Failure,\n      title: \"No timers found!\",\n    });\n  }\n  stopTimer(timers[0].originalFile);\n  await closeMainWindow();\n  showHUD(`Timer \"${timers[0].name}\" stopped!`);\n};\n", "import { environment, getPreferenceValues } from \"@raycast/api\";\nimport { exec } from \"child_process\";\nimport { randomUUID } from \"crypto\";\nimport { existsSync, readdirSync, readFileSync, unlinkSync, writeFileSync } from \"fs\";\nimport { extname } from \"path\";\nimport { CustomTimer, Preferences, RawTimer, Timer, TimerLaunchConfig } from \"./types\";\nimport { formatTime, secondsBetweenDates } from \"./formatUtils\";\nimport { showHudOrToast, showInitialRingContinuouslyWarning } from \"./utils\";\nimport { kill } from \"process\";\n\nconst DATAPATH = environment.supportPath + \"/customTimers.json\";\nconst DEFAULT_PRESET_VISIBLES_FILE = environment.supportPath + \"/defaultPresetVisibles.json\";\n\nconst silentFileDeletion = (fp: string) => {\n  try {\n    unlinkSync(fp);\n  } catch (err) {\n    // only throw if it's not a \"file doesn't exist\" error\n    if (err instanceof Error && !err.message.includes(\"ENOENT\")) throw err;\n  }\n};\n\nconst checkForOverlyLoudAlert = (launchedFromMenuBar = false) => {\n  const prefs = getPreferenceValues<Preferences>();\n  if (parseFloat(prefs.volumeSetting) > 5.0) {\n    const errorMsg = \"Timer alert volume should not be louder than 5 (it can get quite loud!)\";\n    showHudOrToast({ msg: errorMsg, launchedFromMenuBar: launchedFromMenuBar, isErr: true });\n    return false;\n  }\n  return true;\n};\n\nasync function startTimer({\n  timeInSeconds,\n  timerName = \"Untitled\",\n  launchedFromMenuBar = false,\n  selectedSound = \"default\",\n  skipRingContinuouslyWarning = false,\n}: TimerLaunchConfig) {\n  if (!skipRingContinuouslyWarning) {\n    if (!(await showInitialRingContinuouslyWarning())) return;\n  }\n  const fileName = environment.supportPath + \"/\" + new Date().toISOString() + \"---\" + timeInSeconds + \".timer\";\n  const masterName = fileName.replace(/:/g, \"__\");\n\n  const prefs = getPreferenceValues<Preferences>();\n  if (prefs.ringContinuously) {\n    const dismissFile = `${masterName}`.replace(\".timer\", \".dismiss\");\n    writeFileSync(dismissFile, \".dismiss file for Timers\");\n  }\n\n  const cmd = buildTimerCommand(masterName, timerName, timeInSeconds, selectedSound);\n\n  const process = exec(cmd, (error, stderr) => {\n    if (error) {\n      console.log(`error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.log(`stderr: ${stderr}`);\n      return;\n    }\n  });\n\n  const fileContents: RawTimer = {\n    name: timerName,\n    pid: process.pid,\n    lastPaused: \"---\",\n    pauseElapsed: 0,\n    selectedSound: selectedSound === \"default\" ? prefs.selectedSound : selectedSound,\n  };\n  writeFileSync(masterName, JSON.stringify(fileContents));\n  showHudOrToast({\n    msg: `Timer \"${timerName}\" started for ${formatTime(timeInSeconds)}!`,\n    launchedFromMenuBar: launchedFromMenuBar,\n    isErr: false,\n  });\n}\n\nfunction buildTimerCommand(\n  masterName: string,\n  timerName: string,\n  timeInSeconds: number,\n  selectedSound: string,\n): string {\n  const prefs = getPreferenceValues<Preferences>();\n  const selectedSoundPath = `${\n    environment.assetsPath + \"/\" + (selectedSound === \"default\" ? prefs.selectedSound : selectedSound)\n  }`;\n  const cmdParts = [`sleep ${timeInSeconds}`];\n  cmdParts.push(\n    `if [ -f \"${masterName}\" ]; then osascript -e 'display notification \"Timer \\\\\"${timerName}\\\\\" complete\" with title \"Ding!\"'`,\n  );\n  const alertSoundString =\n    prefs.selectedSound === \"speak_timer_name\"\n      ? `say ${timerName}`\n      : `afplay \"${selectedSoundPath}\" --volume ${prefs.volumeSetting.replace(\",\", \".\")}`;\n  cmdParts.push(alertSoundString);\n  if (prefs.ringContinuously) {\n    const dismissFile = `${masterName}`.replace(\".timer\", \".dismiss\");\n    cmdParts.push(`while [ -f \"${dismissFile}\" ]; do ${alertSoundString}; done`);\n  }\n  cmdParts.push(`rm \"${masterName}\"; else echo \"Timer deleted\"; fi`);\n  return cmdParts.join(\" ; \");\n}\n\nfunction stopTimer(timerFile: string) {\n  const timerFilePath = environment.supportPath + \"/\" + timerFile;\n  const dismissFile = timerFilePath.replace(\".timer\", \".dismiss\");\n  silentFileDeletion(timerFilePath);\n  silentFileDeletion(dismissFile);\n}\n\nfunction pauseTimer(timerFile: string, timerPid: number) {\n  const timerFilePath = environment.supportPath + \"/\" + timerFile;\n  kill(timerPid);\n\n  const rawFileContents = readFileSync(timerFilePath).toString();\n  const fileContents: RawTimer = JSON.parse(rawFileContents);\n  fileContents.pid = undefined;\n  fileContents.lastPaused = new Date();\n  writeFileSync(timerFilePath, JSON.stringify(fileContents));\n}\n\nfunction unpauseTimer(timer: Timer) {\n  const timerFilePath = environment.supportPath + \"/\" + timer.originalFile;\n\n  const cmd = buildTimerCommand(timerFilePath, timer.name, timer.timeLeft, timer.selectedSound);\n  const process = exec(cmd);\n\n  const rawFileContents = readFileSync(timerFilePath).toString();\n  const fileContents: RawTimer = JSON.parse(rawFileContents);\n  fileContents.pauseElapsed = fileContents.pauseElapsed + secondsBetweenDates({ d2: timer.lastPaused });\n  fileContents.lastPaused = \"---\";\n  fileContents.pid = process.pid;\n  writeFileSync(timerFilePath, JSON.stringify(fileContents));\n}\n\nfunction getTimers() {\n  const setOfTimers: Timer[] = [];\n  const files = readdirSync(environment.supportPath);\n  files.forEach((timerFile: string) => {\n    if (extname(timerFile) == \".timer\") {\n      const timer: Timer = {\n        name: \"\",\n        secondsSet: -99,\n        timeLeft: -99,\n        originalFile: timerFile,\n        timeEnds: new Date(),\n        pid: undefined,\n        lastPaused: \"---\",\n        pauseElapsed: 0,\n        selectedSound: \"default\",\n      };\n      const rawFileContents = readFileSync(environment.supportPath + \"/\" + timerFile).toString();\n      try {\n        const fileContents: RawTimer = JSON.parse(rawFileContents);\n        timer.name = fileContents.name;\n        timer.pid = fileContents.pid;\n        timer.lastPaused = fileContents.lastPaused;\n        timer.pauseElapsed = fileContents.pauseElapsed;\n        timer.selectedSound = fileContents.selectedSound;\n      } catch (error) {\n        if (!(error instanceof SyntaxError)) throw error;\n        timer.name = rawFileContents;\n      }\n\n      const timerFileParts = timerFile.split(\"---\");\n      timer.secondsSet = Number(timerFileParts[1].split(\".\")[0]);\n      const timeStarted = timerFileParts[0].replace(/__/g, \":\");\n      timer.timeEnds = new Date(timeStarted);\n      timer.timeEnds.setSeconds(timer.timeEnds.getSeconds() + timer.secondsSet + timer.pauseElapsed);\n      timer.timeLeft = Math.max(\n        0,\n        Math.round(\n          timer.pid === undefined\n            ? timer.secondsSet -\n                secondsBetweenDates({\n                  d1: timer.lastPaused === \"---\" ? undefined : timer.lastPaused,\n                  d2: new Date(timeStarted),\n                }) +\n                timer.pauseElapsed\n            : secondsBetweenDates({ d1: timer.timeEnds }),\n        ),\n      );\n      setOfTimers.push(timer);\n    }\n  });\n  setOfTimers.sort((a, b) => {\n    return a.timeLeft - b.timeLeft;\n  });\n  return setOfTimers;\n}\n\nfunction renameTimer(timerFile: string, newName: string) {\n  const timerFilePath = environment.supportPath + \"/\" + timerFile;\n  const rawFileContents = readFileSync(timerFilePath).toString();\n  const fileContents: RawTimer = JSON.parse(rawFileContents);\n  fileContents.name = newName;\n  writeFileSync(timerFilePath, JSON.stringify(fileContents));\n}\n\nfunction ensureCTFileExists() {\n  if (!existsSync(DATAPATH)) {\n    writeFileSync(DATAPATH, JSON.stringify({}));\n  }\n}\n\nfunction createCustomTimer(newTimer: CustomTimer) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  customTimers[randomUUID()] = newTimer;\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nfunction readCustomTimers() {\n  ensureCTFileExists();\n  const res: Record<string, CustomTimer> = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  return Object.fromEntries(\n    Object.entries(res).map(([ctID, timer]) =>\n      timer.showInMenuBar === undefined ? [ctID, { ...timer, showInMenuBar: true }] : [ctID, timer],\n    ),\n  );\n}\n\nfunction renameCustomTimer(ctID: string, newName: string) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  customTimers[ctID].name = newName;\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nfunction deleteCustomTimer(ctID: string) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  delete customTimers[ctID];\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nfunction toggleCustomTimerMenubarVisibility(ctID: string) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  const currentVisibility = customTimers[ctID].showInMenuBar;\n  customTimers[ctID].showInMenuBar = currentVisibility === undefined ? false : !currentVisibility;\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nconst readDefaultPresetVisibles = (): Record<string, boolean> => {\n  if (!existsSync(DEFAULT_PRESET_VISIBLES_FILE)) {\n    const defaultPresetVisibles = {\n      \"2M\": true,\n      \"5M\": true,\n      \"10M\": true,\n      \"15M\": true,\n      \"30M\": true,\n      \"45M\": true,\n      \"60M\": true,\n      \"90M\": true,\n    };\n    writeFileSync(DEFAULT_PRESET_VISIBLES_FILE, JSON.stringify(defaultPresetVisibles));\n    return defaultPresetVisibles;\n  }\n  const res: Record<string, boolean> = JSON.parse(readFileSync(DEFAULT_PRESET_VISIBLES_FILE, \"utf8\"));\n  return res;\n};\n\nconst toggleDefaultPresetVisibility = (key: string) => {\n  const data: Record<string, boolean> = JSON.parse(readFileSync(DEFAULT_PRESET_VISIBLES_FILE, \"utf8\"));\n  data[key] = !data[key];\n  writeFileSync(DEFAULT_PRESET_VISIBLES_FILE, JSON.stringify(data));\n};\n\nexport {\n  checkForOverlyLoudAlert,\n  createCustomTimer,\n  deleteCustomTimer,\n  ensureCTFileExists,\n  getTimers,\n  readCustomTimers,\n  renameTimer,\n  renameCustomTimer,\n  toggleCustomTimerMenubarVisibility,\n  startTimer,\n  stopTimer,\n  pauseTimer,\n  unpauseTimer,\n  readDefaultPresetVisibles,\n  toggleDefaultPresetVisibility,\n};\n", "const formatTime = (seconds: number) => {\n  const hours = Math.floor(seconds / 3600);\n  const mins = String(Math.floor((seconds % 3600) / 60)).padStart(2, \"0\");\n  const secs = String(Math.floor(seconds % 60)).padStart(2, \"0\");\n  return `${hours === 0 ? \"\" : hours + \":\"}${mins}:${secs}`;\n};\n\nconst formatDateTime = (d: Date) => {\n  const parsedDate = new Date(d);\n  const datevalues = [\n    parsedDate.getFullYear().toString(),\n    (parsedDate.getMonth() + 1).toString().padStart(2, \"0\"),\n    parsedDate.getDate().toString().padStart(2, \"0\"),\n  ];\n  const timevalues = [parsedDate.getHours(), parsedDate.getMinutes(), parsedDate.getSeconds()].map((x) =>\n    x.toString().padStart(2, \"0\"),\n  );\n  const date = datevalues.join(\"-\");\n  const time = timevalues.join(\":\");\n  return `${date} ${time}`;\n};\n\nconst secondsBetweenDates = (args: { d1?: Date | string; d2?: Date | string }) => {\n  args.d1 = args.d1 == \"----\" ? undefined : args.d1;\n  args.d2 = args.d2 == \"----\" ? undefined : args.d2;\n  return (\n    Math.round(\n      (args.d1 ? new Date(args.d1) : new Date()).getTime() - (args.d2 ? new Date(args.d2) : new Date()).getTime(),\n    ) / 1000\n  );\n};\n\nexport { formatTime, formatDateTime, secondsBetweenDates };\n", "import {\n  Icon,\n  Toast,\n  confirmAlert,\n  environment,\n  getPreferenceValues,\n  popToRoot,\n  showHUD,\n  showToast,\n} from \"@raycast/api\";\nimport { Preferences } from \"./types\";\nimport { existsSync, writeFileSync } from \"fs\";\n\nconst shortCircuitMenuBar = <T>(state: T[] | undefined, prefs: Preferences): boolean => {\n  return (\n    (state == undefined || state.length == 0 || state.length == undefined) &&\n    ![\"always\", \"onlyWhenNotRunning\"].includes(prefs.showMenuBarIconWhen)\n  );\n};\n\nconst showHudOrToast = (args: { msg: string; launchedFromMenuBar: boolean; isErr: boolean }) => {\n  const prefs: Preferences = getPreferenceValues();\n  if (args.launchedFromMenuBar || prefs.closeWindowOnTimerStart) {\n    const msgEmoji = args.isErr ? \"\u26A0\uFE0F\" : \"\uD83C\uDF89\";\n    showHUD(`${msgEmoji} ${args.msg}`);\n    return popToRoot();\n  } else {\n    showToast({ style: args.isErr ? Toast.Style.Failure : Toast.Style.Success, title: args.msg });\n  }\n};\n\nconst showInitialRingContinuouslyWarning = async (): Promise<boolean> => {\n  const RINGCONTINUOUSLY_SHOWN_PATH = environment.supportPath + \"/ringContinuouslyWarningShown\";\n  const prefs = getPreferenceValues<Preferences>();\n  if (!prefs.ringContinuously) return true;\n  if (existsSync(RINGCONTINUOUSLY_SHOWN_PATH)) return true;\n\n  const result = await confirmAlert({\n    title: \"Ring Continuously is enabled!\",\n    icon: Icon.Bell,\n    message:\n      'When the timer rings, you will need to use the \"Stop Running Timer\" command or stop the timer in the \"Manage Timers\" command to dismiss the sound. You can configure this in your Raycast settings.',\n  });\n  if (result) writeFileSync(RINGCONTINUOUSLY_SHOWN_PATH, \"\");\n  return result;\n};\n\nexport { shortCircuitMenuBar, showHudOrToast, showInitialRingContinuouslyWarning };\n"],
  "mappings": "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",
  "names": ["stopRunningTimer_exports", "__export", "stopRunningTimer_default", "__toCommonJS", "import_api", "import_api", "import_fs", "import_path", "secondsBetweenDates", "args", "import_api", "DATAPATH", "DEFAULT_PRESET_VISIBLES_FILE", "silentFileDeletion", "fp", "err", "stopTimer", "timerFile", "timerFilePath", "dismissFile", "silentFileDeletion", "getTimers", "setOfTimers", "timerFile", "timer", "rawFileContents", "fileContents", "error", "timerFileParts", "timeStarted", "secondsBetweenDates", "a", "b", "stopRunningTimer_default", "timers", "getTimers", "stopTimer"]
}
